package com.elong.pb.newdda.client.jdbc;

import com.elong.pb.newdda.client.executor.StatementExecutor;
import com.elong.pb.newdda.client.jdbc.adapter.AbstractStatementAdapter;
import com.elong.pb.newdda.client.router.SqlExecutionUnit;
import com.elong.pb.newdda.client.router.SqlRouterEngine;
import com.elong.pb.newdda.client.router.SqlRouterResult;
import com.elong.pb.newdda.client.router.result.merge.MergeContext;
import com.elong.pb.newdda.client.router.result.merge.ResultSetFactory;
import com.google.common.hash.HashCode;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;

public class ShardingStatement extends AbstractStatementAdapter {

    //=========================================================  当前的结果  ===================================================================
    private final Map<HashCode, Statement> cachedRoutedStatements = new HashMap<HashCode, Statement>();

    private ResultSet currentResultSet = null;

    private MergeContext mergeContext = null;

    //====================================================== 初始化参数 start  ================================================================
    private final ShardingConnection shardingConnection;

    private final SqlRouterEngine sqlRouterEngine;

    private final int resultSetType;

    private final int resultSetConcurrency;

    private final int resultSetHoldability;

    //====================================================== 初始化参数 end================================================================

    public ShardingStatement(final ShardingConnection shardingConnection, final SqlRouterEngine sqlRouterEngine) throws SQLException {
        this(shardingConnection, sqlRouterEngine, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    public ShardingStatement(final ShardingConnection shardingConnection, final SqlRouterEngine sqlRouterEngine, final int resultSetType, final int resultSetConcurrency) throws SQLException {
        this(shardingConnection, sqlRouterEngine, resultSetType, resultSetConcurrency, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    public ShardingStatement(final ShardingConnection shardingConnection, final SqlRouterEngine sqlRouterEngine, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) {
        this.shardingConnection = shardingConnection;
        this.sqlRouterEngine = sqlRouterEngine;
        this.resultSetType = resultSetType;
        this.resultSetConcurrency = resultSetConcurrency;
        this.resultSetHoldability = resultSetHoldability;
    }

    public Collection<? extends Statement> getRoutedStatements() throws SQLException {
        return cachedRoutedStatements.values();
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        //若存在结果集,则关闭当前的结果集
        if (null != currentResultSet && !currentResultSet.isClosed()) {
            currentResultSet.close();
        }
        StatementExecutor statementExecutor = generateExecutor(sql);
        List<ResultSet> resultSetsList = statementExecutor.executeQuery();
        currentResultSet = ResultSetFactory.getResultSet(resultSetsList, mergeContext);
        return currentResultSet;
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        return 0;
    }

    @Override
    public boolean execute(String sql) throws SQLException {
        return false;
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        return 0;
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        return 0;
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        return 0;
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        return false;
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        return false;
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        return false;
    }

    //======================================================================= 基本参数 start ==================================================================================
    @Override
    public int getResultSetConcurrency() throws SQLException {
        return resultSetConcurrency;
    }

    @Override
    public int getResultSetType() throws SQLException {
        return resultSetType;
    }

    @Override
    public Connection getConnection() throws SQLException {
        return shardingConnection;
    }

    @Override
    public int getResultSetHoldability() throws SQLException {
        return resultSetHoldability;
    }

    //======================================================================= 基本参数 end ==================================================================================
    @Override
    public ResultSet getResultSet() throws SQLException {
        return currentResultSet;
    }
    //======================================================================= private method start ==================================================================

    public StatementExecutor generateExecutor(final String sql) throws SQLException {
        StatementExecutor statementExecutor = new StatementExecutor();
        SqlRouterResult sqlRouteResult = sqlRouterEngine.route(sql, Collections.emptyList());

        this.mergeContext = sqlRouteResult.getMergeContext();

        for (SqlExecutionUnit each : sqlRouteResult.getExecutionUnits()) {

        }

        return statementExecutor;
    }



    //======================================================================= private method end ==================================================================

}
